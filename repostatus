#!/bin/bash

# Repository Status Checker
# Finds all git repos, shows their status, and allows launching lazygit

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/repostatus"
FETCH_LOG="$CACHE_DIR/fetch.log"
mkdir -p "$CACHE_DIR"
: > "$FETCH_LOG"

# Status indicators
CLEAN="ðŸŸ¢"
DIRTY="ðŸŸ¡"
AHEAD="ðŸ”µ"
BEHIND="ðŸŸ "
DIVERGED="ðŸ”´"
UNINITIALIZED="âšª"
FETCH_FAILED="â›”"

FETCH_INTERVAL=${REPOSTATUS_FETCH_INTERVAL:-300}
FORCE_FETCH=${REPOSTATUS_FORCE_FETCH:-0}
DISABLE_FETCH=${REPOSTATUS_DISABLE_FETCH:-0}
LAST_FETCH_FILE="$CACHE_DIR/last_fetch"

get_repo_status() {
    local repo_dir="$1"
    cd "$repo_dir"
    
    # Check if there are any remote branches
    if [ -z "$(git branch -r)" ]; then
        echo "uninitialized"
        return
    fi

    # Get repo name
    local repo_name=$(basename "$repo_dir")
    
    # Check if there are uncommitted changes
    if ! (git diff-index --quiet HEAD -- 2>/dev/null); then
        echo "dirty"
        return
    fi
    
    # Check for untracked files
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        echo "dirty"
        return
    fi
    
    # Check if ahead/behind/diverged from remote
    local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
    if [ -n "$upstream" ]; then
        local local_commit=$(git rev-parse @ 2>/dev/null || true)
        local remote_commit=$(git rev-parse @{u} 2>/dev/null || true)
        local base_commit=$(git merge-base @ @{u} 2>/dev/null || true)
        
        if [ -z "$local_commit" ] || [ -z "$remote_commit" ] || [ -z "$base_commit" ]; then
            # If any of the commits are not found, the repo is likely in a weird state
            # (e.g. empty, no upstream). We'll just call it clean and move on.
            echo "clean"
            return
        fi

        if [ "$local_commit" = "$remote_commit" ]; then
            echo "clean"
        elif [ "$local_commit" = "$base_commit" ]; then
            echo "behind"
        elif [ "$remote_commit" = "$base_commit" ]; then
            echo "ahead"
        else
            echo "diverged"
        fi
    else
        echo "clean"
    fi
}

get_status_icon() {
    case "$1" in
        clean)   echo -e "${GREEN}${CLEAN}${NC}" ;;
        dirty)   echo -e "${YELLOW}${DIRTY}${NC}" ;;
        ahead)   echo -e "${BLUE}${AHEAD}${NC}" ;;
        behind)  echo -e "${YELLOW}${BEHIND}${NC}" ;;
        diverged) echo -e "${RED}${DIVERGED}${NC}" ;;
        uninitialized) echo -e "${NC}${UNINITIALIZED}${NC}" ;;
        fetch_failed) echo -e "${RED}${FETCH_FAILED}${NC}" ;;
        *)       echo -e "${NC}â“${NC}" ;;
    esac
}

get_worst_status() {
    local worst="clean"
    for status in "$@"; do
        case "$status" in
            diverged) worst="diverged"; break ;;
            fetch_failed) worst="fetch_failed" ;;
            dirty|uninitialized) [ "$worst" != "fetch_failed" ] && worst="dirty" ;;
            behind) [ "$worst" != "dirty" ] && [ "$worst" != "fetch_failed" ] && worst="behind" ;;
            ahead) [ "$worst" != "dirty" ] && [ "$worst" != "behind" ] && [ "$worst" != "fetch_failed" ] && worst="ahead" ;;
        esac
    done
    echo "$worst"
}

get_parent_dir() {
    local path="$1"
    local parent=$(dirname "$path")
    local parent_name=$(basename "$parent")
    
    # Check if it's directly in home
    if [ "$parent" = "$HOME" ]; then
        echo "~/$parent_name"
    else
        # Get the first level directory under home
        local rel_path="${path#$HOME/}"
        local first_dir=$(echo "$rel_path" | cut -d'/' -f1)
        echo "~/$first_dir"
    fi
}

sync_repos() {
    local repos_to_sync=("$@")
    
    echo -e "${BLUE}Starting repository sync...${NC}"
    echo ""
    
    for repo_path in "${repos_to_sync[@]}"; do
        cd "$repo_path"
        local repo_name=$(basename "$repo_path")
        local status=$(get_repo_status "$repo_path")
        
        case "$status" in
            behind)
                echo -e "${BLUE}Syncing ${repo_name}...${NC}"
                if git pull --quiet; then
                    echo -e "${GREEN}âœ“ Synced successfully${NC}"
                else
                    echo -e "${RED}âœ— Failed to sync${NC}"
                fi
                ;;
            dirty)
                echo -e "${YELLOW}âœ— Skipping ${repo_name} (has local changes)${NC}"
                ;;
            diverged)
                echo -e "${RED}âœ— Skipping ${repo_name} (diverged from remote)${NC}"
                ;;
            clean|ahead)
                # No action needed
                ;;
        esac
    done
    
    echo ""
    echo -e "${BLUE}Sync complete.${NC}"
    read -p "Press enter to continue..."
}

fetch_all_repos() {
    for i in "${!paths[@]}"; do
        repo_path="${paths[$i]}"
        set +e
        output=$(git -C "$repo_path" fetch --quiet 2>&1)
        exit_code=$?
        set -e
        if [ $exit_code -ne 0 ]; then
            statuses[$i]="fetch_failed"
            fetch_error_msgs[$i]="$output"
            {
                echo "[$(date --iso-8601=seconds)] ${repo_path}"
                echo "$output"
                echo ""
            } >> "$FETCH_LOG"
        fi
    done
}

# Find all git repositories in home directory

declare -a repos
declare -a statuses
declare -a paths
declare -a fetch_error_msgs

# Directories to exclude
EXCLUDE_DIRS=(
    ".local"
    ".cache"
    ".cargo"
    ".npm"
    ".nvm"
    ".rustup"
    "node_modules"
    ".venv"
    "venv"
    ".virtualenv"
)

# Build find exclusion string
EXCLUDE_FIND=""
for dir in "${EXCLUDE_DIRS[@]}"; do
    EXCLUDE_FIND="$EXCLUDE_FIND -path '*/$dir' -prune -o"
done

# Find all .git directories (excluding common directories)
while IFS= read -r -d '' git_dir; do
    repo_dir=$(dirname "$git_dir")
    
    # Skip if inside another git repo
    if [[ "$repo_dir" == *"/.git/"* ]]; then
        continue
    fi
    
    status=$(get_repo_status "$repo_dir")
    repo_name=$(basename "$repo_dir")
    
    repos+=("$repo_name")
    statuses+=("$status")
    paths+=("$repo_dir")
done < <(eval "find ~ $EXCLUDE_FIND -name '.git' -type d -prune -print0 2>/dev/null" | head -z -n 50)

if [ ${#repos[@]} -eq 0 ]; then
    echo -e "${YELLOW}No git repositories found in home directory${NC}"
    exit 0
fi

should_fetch=1
if [ "$DISABLE_FETCH" -eq 1 ]; then
    should_fetch=0
elif [ "$FORCE_FETCH" -eq 0 ] && [ "$FETCH_INTERVAL" -gt 0 ] && [ -f "$LAST_FETCH_FILE" ]; then
    now=$(date +%s)
    last_fetch=$(cat "$LAST_FETCH_FILE" 2>/dev/null || echo 0)
    if [ $((now - last_fetch)) -lt "$FETCH_INTERVAL" ]; then
        should_fetch=0
    fi
fi

if [ "$should_fetch" -eq 1 ]; then
    fetch_all_repos
    date +%s > "$LAST_FETCH_FILE"
fi

# Group repositories by parent directory
declare -A dir_repos
declare -A dir_statuses

for i in "${!repos[@]}"; do
    parent=$(get_parent_dir "${paths[$i]}")
    
    if [ -z "${dir_repos[$parent]}" ]; then
        dir_repos[$parent]="$i"
        dir_statuses[$parent]="${statuses[$i]}"
    else
        dir_repos[$parent]="${dir_repos[$parent]},$i"
        # Update worst status
        current_worst="${dir_statuses[$parent]}"
        new_worst=$(get_worst_status "$current_worst" "${statuses[$i]}")
        dir_statuses[$parent]="$new_worst"
    fi
done

# Handle command-line arguments
case "$1" in
    --sync|-s)
        sync_repos "${paths[@]}"
        exit 0
        ;;
    --json-summary)
        overall_status=$(get_worst_status "${statuses[@]}")
        
        declare -A status_counts=(
            [clean]=0
            [dirty]=0
            [ahead]=0
            [behind]=0
            [diverged]=0
            [uninitialized]=0
            [fetch_failed]=0
        )
        for status in "${statuses[@]}"; do
            if [ -n "$status" ]; then
                status_counts[$status]=$((${status_counts[$status]} + 1))
            fi
        done

        json_output="{\"overall_status\": \"$overall_status\", \"status_counts\": {\"clean\": ${status_counts[clean]}, \"dirty\": ${status_counts[dirty]}, \"ahead\": ${status_counts[ahead]}, \"behind\": ${status_counts[behind]}, \"diverged\": ${status_counts[diverged]}, \"uninitialized\": ${status_counts[uninitialized]}, \"fetch_failed\": ${status_counts[fetch_failed]}}, \"repos\": ["
        
        first=true
        for i in "${!repos[@]}"; do
            if [ "${statuses[$i]}" != "clean" ]; then
                if [ "$first" = true ]; then
                    first=false
                else
                    json_output="$json_output,"
                fi
                
                repo_name_escaped=$(echo "${repos[$i]}" | sed 's/"/\\"/g')
                repo_path_escaped=$(echo "${paths[$i]}" | sed 's/"/\\"/g')

                json_output="$json_output{\"name\": \"$repo_name_escaped\", \"path\": \"$repo_path_escaped\", \"status\": \"${statuses[$i]}\"}"
            fi
        done
        
        json_output="$json_output]}"
        
        echo "$json_output"
        exit 0
        ;;
esac

# Main loop
while true; do
    clear
    echo -e "${BLUE}=== Git Repository Status ===${NC}"
    echo ""
    echo -e "${BLUE}Legend:${NC}"
    echo -e "  ${GREEN}${CLEAN}${NC} Clean   ${YELLOW}${DIRTY}${NC} Dirty   ${BLUE}${AHEAD}${NC} Ahead   ${YELLOW}${BEHIND}${NC} Behind   ${RED}${DIVERGED}${NC} Diverged   ${NC}${UNINITIALIZED}${NC} Uninitialized   ${RED}${FETCH_FAILED}${NC} Fetch failed"
    echo ""
    echo -e "${BLUE}=== Directories ===${NC}"
    echo ""
    
    declare -a dir_list=()
    for dir in "${!dir_repos[@]}"; do
        dir_list+=("$dir")
    done
    
    # Sort directories
    IFS=$'\n' dir_list=($(sort <<<"${dir_list[*]}"))
    unset IFS
    
    # Display directories with summary
    for i in "${!dir_list[@]}"; do
        dir="${dir_list[$i]}"
        icon=$(get_status_icon "${dir_statuses[$dir]}")
        repo_count=$(echo "${dir_repos[$dir]}" | tr ',' '\n' | wc -l)
        printf "%2d) %s  %-30s (%d repos)\n" "$((i+1))" "$icon" "$dir" "$repo_count"
    done
    
    echo ""
    echo "s) Sync All Repos"
    read -p "Select directory to expand, 's' to sync, or 'q' to quit: " choice
    
    if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
        exit 0
    fi

    if [ "$choice" = "s" ] || [ "$choice" = "S" ]; then
        sync_repos "${paths[@]}"
        exec "$0"
    fi
    
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt "${#dir_list[@]}" ]; then
        echo -e "${RED}Invalid selection${NC}"
        sleep 1
        continue
    fi
    
    selected_dir_idx=$((choice - 1))
    selected_dir="${dir_list[$selected_dir_idx]}"
    
    # Show repos in selected directory
    clear
    echo -e "${BLUE}=== Repositories in $selected_dir ===${NC}"
    echo ""
    
    IFS=',' read -ra repo_indices <<< "${dir_repos[$selected_dir]}"
    
    for i in "${!repo_indices[@]}"; do
        idx="${repo_indices[$i]}"
        icon=$(get_status_icon "${statuses[$idx]}")
        printf "%2d) %s  %-40s\n" "$((i+1))" "$icon" "${repos[$idx]}"
        echo -e "    ${BLUE}${paths[$idx]}${NC}"
        if [ "${statuses[$idx]}" = "fetch_failed" ]; then
            echo -e "    ${RED}Last fetch failed. See ${FETCH_LOG}${NC}"
        fi
    done
    
    echo ""
    echo "s) Sync all in this directory"
    echo "b) Back to directory list"
    echo "q) Quit"
    read -p "Select repo to open in lazygit, 's' to sync, 'b' to go back, or 'q' to quit: " repo_choice
    
    if [ "$repo_choice" = "q" ] || [ "$repo_choice" = "Q" ]; then
        exit 0
    fi
    
    if [ "$repo_choice" = "b" ] || [ "$repo_choice" = "B" ]; then
        continue
    fi

    if [ "$repo_choice" = "s" ] || [ "$repo_choice" = "S" ]; then
        declare -a repos_to_sync_in_dir
        for i in "${!repo_indices[@]}"; do
            repos_to_sync_in_dir+=("${paths[${repo_indices[$i]}]}")
        done
        sync_repos "${repos_to_sync_in_dir[@]}"
        exec "$0"
    fi
    
    if ! [[ "$repo_choice" =~ ^[0-9]+$ ]] || [ "$repo_choice" -lt 1 ] || [ "$repo_choice" -gt "${#repo_indices[@]}" ]; then
        echo -e "${RED}Invalid selection${NC}"
        sleep 1
        continue
    fi
    
    selected_repo_idx="${repo_indices[$((repo_choice - 1))]}"
    selected_path="${paths[$selected_repo_idx]}"
    
    echo -e "${GREEN}Launching lazygit in: ${selected_path}${NC}"
    cd "$selected_path"
    
    if command -v lazygit &> /dev/null; then
        lazygit
        # After lazygit exits, rescan repos
        echo ""
        read -p "Press enter to rescan repositories..." 
        exec "$0"
    else
        echo -e "${RED}lazygit not found.${NC}"
        echo -e "${BLUE}Install with: sudo pacman -S lazygit${NC}"
        sleep 2
    fi
done
